import threading
import time
from datetime import datetime, timedelta

# A közös lista és hozzá tartozó lock
lista = []
azonositok = set()
lock = threading.Lock()

# Elem hozzáadása
def hozzaad(elem):
    with lock:
        if elem["id"] not in azonositok:
            elem["idopont"] = datetime.now()
            lista.append(elem)
            azonositok.add(elem["id"])
            print(f"Hozzáadva: {elem}")
        else:
            print(f"Már létezik: {elem['id']}")

# Új: Elem törlése ID alapján
def torol(azonosito):
    with lock:
        torlendo = [elem for elem in lista if elem["id"] == azonosito]
        if torlendo:
            for elem in torlendo:
                lista.remove(elem)
            azonositok.discard(azonosito)
            print(f"Törölve kézzel: {azonosito}")
        else:
            print(f"Nem található: {azonosito}")

# Háttérszál: régi elemek törlése
def karbantarto():
    while True:
        time.sleep(5)  # csak 5 mp-enként vizsgál
        with lock:
            most = datetime.now()
            uj_lista = []
            uj_azonositok = set()
            for elem in lista:
                if most - elem["idopont"] < timedelta(seconds=30):
                    uj_lista.append(elem)
                    uj_azonositok.add(elem["id"])
                else:
                    print(f"Törölve (lejárt): {elem}")
            lista.clear()
            lista.extend(uj_lista)
            azonositok.clear()
            azonositok.update(uj_azonositok)

# Háttérszál indítása
threading.Thread(target=karbantarto, daemon=True).start()

# Teszt – néhány elem hozzáadása és kézi törlés
hozzaad({"id": 1})
time.sleep(1)
hozzaad({"id": 2})
time.sleep(1)
torol(1)  # kézzel töröljük az ID=1 elemet
time.sleep(1)
torol(3)  # nem létező ID

# Folyamatos állapotkiírás
while True:
    with lock:
        print(f"Lista állapota ({len(lista)} elem): {[e['id'] for e in lista]}")
    time.sleep(10)

